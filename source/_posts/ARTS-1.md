---
title: ARTS-1
date: 2020-06-07 16:29:45
tags: arts
---

# Algorithm

[33.Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/) 

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

有序数组查找，方向是二分查找。但数组又比较特殊不是完全有序的。
二分查找本质是每次缩小一半的范围，那是否能判断出在哪个范围内呢？发现数组有一半是有序的，另一半则是无序的，无序那边只能放弃，有序的那边可以判断。发现这个规律还是花了些时间。

``` Java
class Solution {
    public static int search(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        while (low <= high) {
            int mid = (low + high) >>> 1;
            int midVal = nums[mid];
            if (target == midVal) {
                return mid;
            }
            if (nums[low] <= midVal) {
                // left is sorted, right is rotated.
                if (nums[low] <= target && target < midVal) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            } else {
                // left is rotated, right is sorted.
                if (midVal < target && target <= nums[high]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }
        return -1;
    }
}
```



# Tip

项目中遇到了 ArrayList 的 ConcurrentModificationException 异常。伪代码如下：

``` Java
Iterator<Callback> iterator = callbackList.iterator();
while (iterator.hasNext()) {
  final Callback callback = iterator.next();
  if (callback.isDestroy()) {
    iterator.remove();
  } else {
    notifyCallback(callback);
  }         
}
```

我知道这个异常只有两种原因

1. 多线程并发修改 List，如其名
2. List 迭代中增加或删除了元素

我自认为对这个异常是很清楚的，但是排查问题依然花了很久很久，查明后问题又是如此的显然，所以记录一下避免自己再犯类似错误。
首先我想先看看是否是多线程问题，直接阅读代码与搜索引用，从我之前对这部分的理解，只有主线程操作。很好，那问题就只剩下迭代中修改了，问题范围就很小了。
但是我反复阅读迭代部分之后，虽然有修改列表，是用 `iterator.remove()` 正确移除的，`notifyCallback` 方法内也没有移除，看起来没有问题，很是奇怪，难道真有多线程修改？
没办法，在列表的所有修改位置打断点增加日志打印线程名，确认确实都在主线程。
再次看迭代部分，还是百思不得其解，怎么看都没问题。难道我对 ConcurrentModificationException 异常的理解有误？于是又搜索+看源码，重新理解了一遍，确认自己理解是正确的。
那到底哪里出了问题呢？聪明的读者估计一早就发现疑点，急不可耐的想指给我了，然而当时的我脑子全是浆糊，感觉代码怎么都没有问题。
最后想不到更好的办法，在 remove、notifyCallback 以及其他修改等位置逐渐增加日志信息，线程名，没问题，调用顺序，没问题。直到日志打印了 callbackList.size() ，不对有大问题，notifyCallback 之后列表变少了。追踪代码，发现 notifyCallback 之后隔了很长很长的调用链，最终修改了 callbackList，导致了迭代中修改列表。
写了这么多流水账，主要是想把自己糟糕的排查思路记录下来，引以为戒。
最后反思，其实如最初预计的，在清楚这个异常的原因时，这个问题是非常显然的，我在排除多线程问题后，只需要紧盯着迭代中修改，就可以立即发现问题。但是我当时怀疑自己对这个异常的理解不对，排查方向就乱了。

# Review

新牛要讲设计，所以在看设计相关的文章，重温了官方的[应用架构指南](https://developer.android.google.cn/jetpack/docs/guide)




# Share

一年多前买了张绍文的《Android 开发高手课》，粗略看了一些，当时的感想是讲的内容与平时的开发有点远，讲的内容用不上，看起来有点吃力。不只是我，很多读者都有类似反馈。
比如内存优化和卡顿优化的章节，不像平时看到的分享（包括官方的 [Android Performance Patterns](https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE)）主要讲问题发生的原因以及针对每种情况如何处理，课程几乎没有讲如何处理，而是在讲如何监控，如何用各种手段提高监控精度和做到线上监控。
当时我是不理解的，只讲监控，却没有讲如何解决。但是现在再看，有了完全不同的感受，发现这些内容正是目前团队遇到的痛点。
我之前的团队规模小，大家对项目代码都很熟悉，所以还有可能通过排查代码的方式解决现存问题，通过 review 避免引入新问题。项目功能不少但所用技术并不复杂，只有 Web 和原生，所以定位问题（分锅）也相对简单，也没有遇到那么多 native 异常。
但上述人工的方式对于大团队和复杂项目是不现实的。代码量大、使用技术复杂、多团队协作，这让问题的发现和定位都变得困难很多。比如线上发生了 OOM，是 cocos 占内存太多了？还是 Native 有内存泄露？还是 C++ JNI 泄露？还是兼而有之？而且在本地无法复现问题，怎么办？在没有监控和现场记录的情况下，想定位问题如大海捞针。
所以发现问题定位问题才是困难的，而定位后解决问题是相对简单的。这就好像程序员平时对 QA 说的，只要能复现问题，就一定能解决。那要如何发现问题呢？监控和现场信息记录。这就是为什么课程都在教如何更好的监控。
大厂通常很早就遇到了这个问题并着手解决，监控需求一般也都很通用，所以很多都逐渐做成了基础设施，由专门的人或架构组负责，后来的开发者对这类问题的接触机会也较少了。比如

## 笔记整理：关于监控和架构

监控和架构需要两手抓，一个好的监控可以帮助我们及时发现问题，而一个好的架构可以减少甚至避免我们犯错。

### 监控

很多性能优化工作其实都是“三分靠优化，七分靠监控”。
为什么监控这么重要？对于大公司来说，每一个项目参与人员可能成百上千人。并且大公司要的不是今天或者这个版本可以做好一些事情，而是希望保证每天每个版本都能持续保持应用的高质量。另一方面有了完善的分析和监控的平台，我们可以把复杂的事情简单化，把一些看起来“高不可攀”的优化工作，变成人人都可以做。
最后多谈两句我的感受，我们在工作的时候，希望你可以看得更远，从更高的角度去思考问题。多想想如果我能做好这件事情，怎么保证其他人不会犯错，或者让所有人都可以做得更好。

### 架构

**如果说监控是为了发现问题，核心在于“防”，那好的架构可以直接避免出现问题，所以架构设计的目标在于“治”。**

架构是面对业务需求场景给出合适的解决方案，使业务能够快速迭代，从而达到“提质增效”的目标。
比如为了解决 UI 渲染卡顿这个场景，可以设计异步布局与主线程渲染这个架构。架构只是设计的抽象，框架是架构的具体实现。好的框架应该隐藏大家不需要关心的部分，提升我们的效率。例如 Facebook 的 [Litho](https://github.com/facebook/litho) 框架就实现了异步布局，并且让开发者可以简单使用。

#### 架构选型

框架选择三个因素：框架成熟度、工具链成熟度、学习成本和社区支持

[康威定律]( https://blog.csdn.net/junecauzhang/article/details/61427915 )是架构选型比较重要的准则，我们的组织架构、代码架构以及流程都应该跟我们团队的规模相匹配。架构设计或者架构选型不能好高骛远，我们有多大的规模，就做多少的支撑。警惕长期的事情短期做，或者短期的事情长期做。
作者举例微信在 2013 年进行模块化，拆分 Module 隔离代码但是保留同一个仓库，而与此同时淘宝则是进行了组件化，拆分了多个仓库。原因是，当时微信还是一个团队开发，一共不到 30 人，但淘宝当时已经几百人在一个应用上开发，并且分属全国各地的不同团队。

#### 架构演进

业务发展过程中，总会遇到新的问题，同时有些旧的问题到某一时刻不存在了。比如为了兼容 Android 4.X，架构上可能需要做大量兼容设计，而当不再需要兼容 4.X 时，这些历史包袱就可以适时抛弃掉。

如何做架构演进

- **演进式的，符合团队现状的。**我们很难找到一个性能最好、成本最省、时间最快的方案，需要权衡性能、成本、时间三者的关系。如果我们时间充裕，那可以朝着更好的性能目标去努力。但如果时间紧急，我们可以分阶段去重构。
- **可度量的，每个阶段都要有成果。**架构演进不能一味“憋大招”，最好能分阶段实施，并且每个阶段都要有成果。这样可以让团队成员更快地感受到优化成果，也可以激励更多的人参与到重构的事业中。

